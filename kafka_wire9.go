// MACHINE GENERATED BY 'go generate' COMMAND
// TO EDIT A TYPE OR METHOD, COPY IT TO ANOTHER FILE IN THE PACKAGE
package main

import (
	"encoding/binary"
	"bytes"
	"io"
	"fmt"
)

func writestring(w io.Writer, s string, must int) (err error) {
	data := []byte(s)
	switch l := len(data); {
	case l > must:
		_, err = w.Write(data[:must])
	case l < must:
		_, err = w.Write(data[:l])
		if err != nil {
			return err
		}
		underflow := must - l
		_, err = w.Write(bytes.Repeat([]byte{0x00}, underflow))
	default:
		_, err = w.Write(data[:l])
	}
	return err
}

func ioErr(name, kind string, ac, ex int) error {
	return fmt.Errorf("%s: short %s: %d/%d", name, kind, ac, ex)
}

type Str struct {
	N	uint32
	data	[]byte
}

type TX struct {
	ApiKey		uint16
	ApiVer		uint16
	CorrelationID	uint32
	ClientID	Str
}

type MetaDataTX struct {
	TX TX
}

type ProduceTX struct {
	TX TX
}

type FetchTX struct {
	TX TX
}

type OffsetTX struct {
	TX TX
}

type OffsetCommitTX struct {
	TX TX
}

type OffsetFetchTX struct {
	TX TX
}

type RX struct {
	CorrelationID	uint32
	ClientID	Str
}

type MetaDataRX struct {
	RX RX
}

type ProduceRX struct {
	RX RX
}

type FetchRX struct {
	RX RX
}

type OffsetRX struct {
	RX RX
}

type OffsetCommitRX struct {
	RX RX
}

type OffsetFetchRX struct {
	RX RX
}

type Tag struct {
	KeyLen		varint
	Key		Str
	ValueLen	varint
	Value		Str
}

type Headers struct {
	N	uint32
	Header	[]Tag
}

type Record struct {
	Len		varint
	Attr		byte
	TimeDelta	varint
	OffsetDelta	varint
	Tag		Tag
	Headers		Headers
}

type RecordBatch struct {
	Offset		uint64
	Len		uint64
	LeaderEpoch	uint32
	Magic		byte
	Attr		uint16
	LastOffsetDelta	uint32
	FirstTime	uint64
	MaxTime		uint64
	ProdID		uint64
	ProdEpoch	uint16
	FirstSeq	uint32
	N		uint32
	Records		[]Record
}

type Broker struct {
	ID	uint32
	Host	Str
	Port	uint32
}

type MetaPart struct {
	Err		uint16
	ID		uint32
	Leader		uint32
	Replicas	uint32
	ISR		uint32
}

type MetaTopic struct {
	Err		uint16
	Topic		Str
	N		uint32
	MetaParts	[]MetaPart
}

type MetaTopicTX struct {
	N	uint32
	Topics	[]Str
}

type MetaTopicRX struct {
	N	uint32
	Brokers	[]Broker
	M	uint32
	Topics	[]MetaTopic
}

type ProdTXPart struct {
	ID		uint32
	MessageSetSize	uint32
	MessageSet	uint32
}

type ProdTXTopic struct {
	Name	Str
	N	uint32
	Parts	[]ProdTxPart
}

type ProdTX struct {
	NeedAcks	uint16
	Timeout		uint32
	N		uint32
	Topics		[]ProdTXTopic
}

type ProdRXPart struct {
	ID	uint32
	Err	uint16
	Offset	uint64
	Time	uint64
}

type ProdRXTopic struct {
	Name	Str
	N	uint32
	Parts	[]ProdRXPart
}

type ProdRX struct {
	N		uint32
	Topics		[]ProdRXTopic
	ThrottleTime	uint32
}

type FetchTXPart struct {
	ID		uint32
	Offset		uint64
	MaxBytes	uint32
}

type FetchTXTopic struct {
	Name	Str
	N	uint32
	Parts	[]FetchTXPart
}

type FetchTX struct {
	ReplicaId	uint32
	MaxWait		uint32
	MinBytes	uint32
	N		uint32
	Topic		[]FetchTXTopic
}

type FetchRXPart struct {
	ID		uint32
	Err		uint16
	HiWater		uint64
	MessageSetSize	uint32
	MessageSet	uint32
}

type FetchRXTopic struct {
	Name	Str
	N	uint32
	Parts	[]FetchRXPart
}

type FetchRX struct {
	ThrottleTime	uint32
	N		uint32
	Topics		[]FetchRXTopic
}

type OffsetTXPart struct {
	ID		uint32
	Time		uint64
	MaxOffsets	uint32
}

type OffsetTXTopic struct {
	Name	Str
	N	uint32
	Parts	[]OffsetTXPart
}

type OffsetTX struct {
	ReplicaId	uint32
	N		uint32
	Topics		[]OffsetTXTopic
}

type Offset struct {
	Q0 uint64
}

type OffsetRXPart struct {
	ID	uint32
	Err	uint16
	Time	uint64
	N	uint32
	Offsets	[]Offset
}

type OffsetRXTopic struct {
	Name	Str
	N	uint32
	Parts	[]OffsetRXPart
}

type OffsetRX struct {
	N	uint32
	Topics	[]OffsetRXTopic
}

type GroupCoTX struct {
	Group Str
}

type GroupCoRX struct {
	Err	uint16
	ID	uint32
	Host	Str
	Port	uint32
}

type CommitTXPart struct {
	ID		uint32
	Offset		uint64
	MetaData	Str
}

type CommitTXTopic struct {
	Name	Str
	N	uint32
	Parts	[]CommitTXPart
}

type CommitTX struct {
	Group	Str
	Gen	uint32
	Cons	Str
	Retain	uint64
	N	uint32
	Topics	[]CommitTXTopic
}

type CommitRXPart struct {
	ID	uint32
	Err	uint16
}

type CommitRXTopic struct {
	Name	Str
	N	uint32
	Parts	[]CommitRXPart
}

type CommitRX struct {
	N	uint32
	Topic	CommitRXTopic
}

type FetchTXPart struct {
	ID uint32
}

type FetchTXTopic struct {
	Name		Str
	N		uint32
	Parition	[]FetchTXPart
}

type FetchTX struct {
	Group	Str
	N	uint32
	Topic	[]FetchTXTopic
}

type FetchRxPart struct {
	ID		uint32
	Offset		uint64
	MetaData	Str
	Err		uint16
}

type FetchRxTopic struct {
	Name	Str
	N	uint32
	Parts	[]FetchTXPart
}

type FetchRX struct {
	N	uint32
	Topic	FetchRxTopic
}

type Proto struct {
	Name		Str
	MetaData	Str
}

type DefaultProto struct {
	Ver		uint16
	N		uint32
	TopicNames	[]Str
}

type JoinGroupTX struct {
	Group			Str
	Timeout			uint32
	RebalanceTimeout	uint32
	Member			Str
	Prototype		Str
	N			uint32
	Protos			[]Proto
}

type JoinGroupRX struct {
	Err	uint16
	GenID	uint32
	Proto	Str
	Leader	Str
	Member	Str
	N	uint32
	Members	[]Proto
}

type AssignPart struct {
	ID uint32
}

type AssignTopic struct {
	N	uint32
	Parts	[]AssignPart
}

type AssignMember struct {
	Ver		uint16
	N		uint32
	Parts		[]AssignTopic
	UserData	Str
}

type GroupAssign struct {
	Member	Str
	N	uint32
	Assigns	[]AssignMember
}

type SyncGroupTX struct {
	Group	Str
	Gen	uint32
	Member	Str
	N	uint32
	Assigns	[]GroupAssign
}

type SyncGroupRX struct {
	Err	uint16
	N	uint32
	Assigns	[]AssignMember
}

type LeaveGroupTX struct {
	Group	Str
	Member	Str
}

type LeaveGroupRX struct {
	Err uint16
}

type HeartTX struct {
	Group	Str
	Gen	uint32
	Member	Str
}

type HeartRX struct {
	Err uint16
}

type GroupList struct {
	Group		Str
	Prototype	Str
}

type ListGroupsTX struct {
	Zero byte
}

type ListGroupsRX struct {
	Err	uint16
	N	uint32
	Groups	[]GroupList
}

type DescGroupsTX struct {
	N	uint32
	Groups	[]Str
}

type DescGroupMember struct {
	Name		Str
	Client		Str
	Host		Str
	MetaData	Str
	N		uint32
	Assigns		[]GroupAssign
}

type DescGroup struct {
	Err		uint16
	Group		Str
	State		Str
	Prototype	Str
	Proto		Str
	N		uint32
	Members		[]DescGroupMember
}

type DescGroupsRX struct {
	Err	uint16
	Group	Str
}

func (z *Str) ReadBinary(r io.Reader) (err error) {
	defer func() { recover() }()
	if z == nil {
		return fmt.Errorf("ReadBinary: z nil")
	}

	if err := binary.Read(r, binary.LittleEndian, &z.N); err != nil {
		return err
	}

	z.data = make([]byte, int(z.N))

	if n, err := r.Read(z.data); err != nil || n != int(z.N) {
		return err
	}

	return nil
}

func (z *Str) WriteBinary(w io.Writer) (err error) {
	defer func() { recover() }()

	if err := binary.Write(w, binary.LittleEndian, z.N); err != nil {
		return err
	}

	{
		x := int(z.N)
		if n, err := w.Write(z.data[:x]); err != nil || n != x {
			return err
		}
	}
	return nil
}

func (z *TX) ReadBinary(r io.Reader) (err error) {
	defer func() { recover() }()
	if z == nil {
		return fmt.Errorf("ReadBinary: z nil")
	}

	if err := binary.Read(r, binary.LittleEndian, &z.ApiKey); err != nil {
		return err
	}

	if err := binary.Read(r, binary.LittleEndian, &z.ApiVer); err != nil {
		return err
	}

	if err := binary.Read(r, binary.LittleEndian, &z.CorrelationID); err != nil {
		return err
	}

	if err := z.ClientID.ReadBinary(r); err != nil {
		return err
	}

	return nil
}

func (z *TX) WriteBinary(w io.Writer) (err error) {
	defer func() { recover() }()

	if err := binary.Write(w, binary.LittleEndian, z.ApiKey); err != nil {
		return err
	}

	if err := binary.Write(w, binary.LittleEndian, z.ApiVer); err != nil {
		return err
	}

	if err := binary.Write(w, binary.LittleEndian, z.CorrelationID); err != nil {
		return err
	}

	if err := z.ClientID.WriteBinary(w); err != nil {
		return err
	}

	return nil
}

func (z *MetaDataTX) ReadBinary(r io.Reader) (err error) {
	defer func() { recover() }()
	if z == nil {
		return fmt.Errorf("ReadBinary: z nil")
	}

	if err := z.TX.ReadBinary(r); err != nil {
		return err
	}

	return nil
}

func (z *MetaDataTX) WriteBinary(w io.Writer) (err error) {
	defer func() { recover() }()

	if err := z.TX.WriteBinary(w); err != nil {
		return err
	}

	return nil
}

func (z *ProduceTX) ReadBinary(r io.Reader) (err error) {
	defer func() { recover() }()
	if z == nil {
		return fmt.Errorf("ReadBinary: z nil")
	}

	if err := z.TX.ReadBinary(r); err != nil {
		return err
	}

	return nil
}

func (z *ProduceTX) WriteBinary(w io.Writer) (err error) {
	defer func() { recover() }()

	if err := z.TX.WriteBinary(w); err != nil {
		return err
	}

	return nil
}

func (z *FetchTX) ReadBinary(r io.Reader) (err error) {
	defer func() { recover() }()
	if z == nil {
		return fmt.Errorf("ReadBinary: z nil")
	}

	if err := z.TX.ReadBinary(r); err != nil {
		return err
	}

	return nil
}

func (z *FetchTX) WriteBinary(w io.Writer) (err error) {
	defer func() { recover() }()

	if err := z.TX.WriteBinary(w); err != nil {
		return err
	}

	return nil
}

func (z *OffsetTX) ReadBinary(r io.Reader) (err error) {
	defer func() { recover() }()
	if z == nil {
		return fmt.Errorf("ReadBinary: z nil")
	}

	if err := z.TX.ReadBinary(r); err != nil {
		return err
	}

	return nil
}

func (z *OffsetTX) WriteBinary(w io.Writer) (err error) {
	defer func() { recover() }()

	if err := z.TX.WriteBinary(w); err != nil {
		return err
	}

	return nil
}

func (z *OffsetCommitTX) ReadBinary(r io.Reader) (err error) {
	defer func() { recover() }()
	if z == nil {
		return fmt.Errorf("ReadBinary: z nil")
	}

	if err := z.TX.ReadBinary(r); err != nil {
		return err
	}

	return nil
}

func (z *OffsetCommitTX) WriteBinary(w io.Writer) (err error) {
	defer func() { recover() }()

	if err := z.TX.WriteBinary(w); err != nil {
		return err
	}

	return nil
}

func (z *OffsetFetchTX) ReadBinary(r io.Reader) (err error) {
	defer func() { recover() }()
	if z == nil {
		return fmt.Errorf("ReadBinary: z nil")
	}

	if err := z.TX.ReadBinary(r); err != nil {
		return err
	}

	return nil
}

func (z *OffsetFetchTX) WriteBinary(w io.Writer) (err error) {
	defer func() { recover() }()

	if err := z.TX.WriteBinary(w); err != nil {
		return err
	}

	return nil
}

func (z *RX) ReadBinary(r io.Reader) (err error) {
	defer func() { recover() }()
	if z == nil {
		return fmt.Errorf("ReadBinary: z nil")
	}

	if err := binary.Read(r, binary.LittleEndian, &z.CorrelationID); err != nil {
		return err
	}

	if err := z.ClientID.ReadBinary(r); err != nil {
		return err
	}

	return nil
}

func (z *RX) WriteBinary(w io.Writer) (err error) {
	defer func() { recover() }()

	if err := binary.Write(w, binary.LittleEndian, z.CorrelationID); err != nil {
		return err
	}

	if err := z.ClientID.WriteBinary(w); err != nil {
		return err
	}

	return nil
}

func (z *MetaDataRX) ReadBinary(r io.Reader) (err error) {
	defer func() { recover() }()
	if z == nil {
		return fmt.Errorf("ReadBinary: z nil")
	}

	if err := z.RX.ReadBinary(r); err != nil {
		return err
	}

	return nil
}

func (z *MetaDataRX) WriteBinary(w io.Writer) (err error) {
	defer func() { recover() }()

	if err := z.RX.WriteBinary(w); err != nil {
		return err
	}

	return nil
}

func (z *ProduceRX) ReadBinary(r io.Reader) (err error) {
	defer func() { recover() }()
	if z == nil {
		return fmt.Errorf("ReadBinary: z nil")
	}

	if err := z.RX.ReadBinary(r); err != nil {
		return err
	}

	return nil
}

func (z *ProduceRX) WriteBinary(w io.Writer) (err error) {
	defer func() { recover() }()

	if err := z.RX.WriteBinary(w); err != nil {
		return err
	}

	return nil
}

func (z *FetchRX) ReadBinary(r io.Reader) (err error) {
	defer func() { recover() }()
	if z == nil {
		return fmt.Errorf("ReadBinary: z nil")
	}

	if err := z.RX.ReadBinary(r); err != nil {
		return err
	}

	return nil
}

func (z *FetchRX) WriteBinary(w io.Writer) (err error) {
	defer func() { recover() }()

	if err := z.RX.WriteBinary(w); err != nil {
		return err
	}

	return nil
}

func (z *OffsetRX) ReadBinary(r io.Reader) (err error) {
	defer func() { recover() }()
	if z == nil {
		return fmt.Errorf("ReadBinary: z nil")
	}

	if err := z.RX.ReadBinary(r); err != nil {
		return err
	}

	return nil
}

func (z *OffsetRX) WriteBinary(w io.Writer) (err error) {
	defer func() { recover() }()

	if err := z.RX.WriteBinary(w); err != nil {
		return err
	}

	return nil
}

func (z *OffsetCommitRX) ReadBinary(r io.Reader) (err error) {
	defer func() { recover() }()
	if z == nil {
		return fmt.Errorf("ReadBinary: z nil")
	}

	if err := z.RX.ReadBinary(r); err != nil {
		return err
	}

	return nil
}

func (z *OffsetCommitRX) WriteBinary(w io.Writer) (err error) {
	defer func() { recover() }()

	if err := z.RX.WriteBinary(w); err != nil {
		return err
	}

	return nil
}

func (z *OffsetFetchRX) ReadBinary(r io.Reader) (err error) {
	defer func() { recover() }()
	if z == nil {
		return fmt.Errorf("ReadBinary: z nil")
	}

	if err := z.RX.ReadBinary(r); err != nil {
		return err
	}

	return nil
}

func (z *OffsetFetchRX) WriteBinary(w io.Writer) (err error) {
	defer func() { recover() }()

	if err := z.RX.WriteBinary(w); err != nil {
		return err
	}

	return nil
}

func (z *Tag) ReadBinary(r io.Reader) (err error) {
	defer func() { recover() }()
	if z == nil {
		return fmt.Errorf("ReadBinary: z nil")
	}

	if err := z.KeyLen.ReadBinary(r); err != nil {
		return err
	}

	if err := z.Key.ReadBinary(r); err != nil {
		return err
	}

	if err := z.ValueLen.ReadBinary(r); err != nil {
		return err
	}

	if err := z.Value.ReadBinary(r); err != nil {
		return err
	}

	return nil
}

func (z *Tag) WriteBinary(w io.Writer) (err error) {
	defer func() { recover() }()

	if err := z.KeyLen.WriteBinary(w); err != nil {
		return err
	}

	if err := z.Key.WriteBinary(w); err != nil {
		return err
	}

	if err := z.ValueLen.WriteBinary(w); err != nil {
		return err
	}

	if err := z.Value.WriteBinary(w); err != nil {
		return err
	}

	return nil
}

func (z *Headers) ReadBinary(r io.Reader) (err error) {
	defer func() { recover() }()
	if z == nil {
		return fmt.Errorf("ReadBinary: z nil")
	}

	if err := binary.Read(r, binary.LittleEndian, &z.N); err != nil {
		return err
	}

	z.Header = make([]Tag, int(z.N))
	for i := 0; i < int(z.N); i++ {

		if err := z.Header[i].ReadBinary(r); err != nil {
			return err
		}
	}

	return nil
}

func (z *Headers) WriteBinary(w io.Writer) (err error) {
	defer func() { recover() }()

	if err := binary.Write(w, binary.LittleEndian, z.N); err != nil {
		return err
	}

	z.Header = make([]Tag, int(z.N))
	for i := 0; i < int(z.N); i++ {
		if err := z.Header[i].WriteBinary(w); err != nil {
			return err
		}
	}

	return nil
}

func (z *Record) ReadBinary(r io.Reader) (err error) {
	defer func() { recover() }()
	if z == nil {
		return fmt.Errorf("ReadBinary: z nil")
	}

	if err := z.Len.ReadBinary(r); err != nil {
		return err
	}

	if err := binary.Read(r, binary.LittleEndian, &z.Attr); err != nil {
		return err
	}

	if err := z.TimeDelta.ReadBinary(r); err != nil {
		return err
	}

	if err := z.OffsetDelta.ReadBinary(r); err != nil {
		return err
	}

	if err := z.Tag.ReadBinary(r); err != nil {
		return err
	}

	if err := z.Headers.ReadBinary(r); err != nil {
		return err
	}

	return nil
}

func (z *Record) WriteBinary(w io.Writer) (err error) {
	defer func() { recover() }()

	if err := z.Len.WriteBinary(w); err != nil {
		return err
	}

	if err := binary.Write(w, binary.LittleEndian, z.Attr); err != nil {
		return err
	}

	if err := z.TimeDelta.WriteBinary(w); err != nil {
		return err
	}

	if err := z.OffsetDelta.WriteBinary(w); err != nil {
		return err
	}

	if err := z.Tag.WriteBinary(w); err != nil {
		return err
	}

	if err := z.Headers.WriteBinary(w); err != nil {
		return err
	}

	return nil
}

func (z *RecordBatch) ReadBinary(r io.Reader) (err error) {
	defer func() { recover() }()
	if z == nil {
		return fmt.Errorf("ReadBinary: z nil")
	}

	if err := binary.Read(r, binary.LittleEndian, &z.Offset); err != nil {
		return err
	}

	if err := binary.Read(r, binary.LittleEndian, &z.Len); err != nil {
		return err
	}

	if err := binary.Read(r, binary.LittleEndian, &z.LeaderEpoch); err != nil {
		return err
	}

	if err := binary.Read(r, binary.LittleEndian, &z.Magic); err != nil {
		return err
	}

	if err := binary.Read(r, binary.LittleEndian, &z.Attr); err != nil {
		return err
	}

	if err := binary.Read(r, binary.LittleEndian, &z.LastOffsetDelta); err != nil {
		return err
	}

	if err := binary.Read(r, binary.LittleEndian, &z.FirstTime); err != nil {
		return err
	}

	if err := binary.Read(r, binary.LittleEndian, &z.MaxTime); err != nil {
		return err
	}

	if err := binary.Read(r, binary.LittleEndian, &z.ProdID); err != nil {
		return err
	}

	if err := binary.Read(r, binary.LittleEndian, &z.ProdEpoch); err != nil {
		return err
	}

	if err := binary.Read(r, binary.LittleEndian, &z.FirstSeq); err != nil {
		return err
	}

	if err := binary.Read(r, binary.LittleEndian, &z.N); err != nil {
		return err
	}

	z.Records = make([]Record, int(z.N))
	for i := 0; i < int(z.N); i++ {

		if err := z.Records[i].ReadBinary(r); err != nil {
			return err
		}
	}

	return nil
}

func (z *RecordBatch) WriteBinary(w io.Writer) (err error) {
	defer func() { recover() }()

	if err := binary.Write(w, binary.LittleEndian, z.Offset); err != nil {
		return err
	}

	if err := binary.Write(w, binary.LittleEndian, z.Len); err != nil {
		return err
	}

	if err := binary.Write(w, binary.LittleEndian, z.LeaderEpoch); err != nil {
		return err
	}

	if err := binary.Write(w, binary.LittleEndian, z.Magic); err != nil {
		return err
	}

	if err := binary.Write(w, binary.LittleEndian, z.Attr); err != nil {
		return err
	}

	if err := binary.Write(w, binary.LittleEndian, z.LastOffsetDelta); err != nil {
		return err
	}

	if err := binary.Write(w, binary.LittleEndian, z.FirstTime); err != nil {
		return err
	}

	if err := binary.Write(w, binary.LittleEndian, z.MaxTime); err != nil {
		return err
	}

	if err := binary.Write(w, binary.LittleEndian, z.ProdID); err != nil {
		return err
	}

	if err := binary.Write(w, binary.LittleEndian, z.ProdEpoch); err != nil {
		return err
	}

	if err := binary.Write(w, binary.LittleEndian, z.FirstSeq); err != nil {
		return err
	}

	if err := binary.Write(w, binary.LittleEndian, z.N); err != nil {
		return err
	}

	z.Records = make([]Record, int(z.N))
	for i := 0; i < int(z.N); i++ {
		if err := z.Records[i].WriteBinary(w); err != nil {
			return err
		}
	}

	return nil
}

func (z *Broker) ReadBinary(r io.Reader) (err error) {
	defer func() { recover() }()
	if z == nil {
		return fmt.Errorf("ReadBinary: z nil")
	}

	if err := binary.Read(r, binary.LittleEndian, &z.ID); err != nil {
		return err
	}

	if err := z.Host.ReadBinary(r); err != nil {
		return err
	}

	if err := binary.Read(r, binary.LittleEndian, &z.Port); err != nil {
		return err
	}

	return nil
}

func (z *Broker) WriteBinary(w io.Writer) (err error) {
	defer func() { recover() }()

	if err := binary.Write(w, binary.LittleEndian, z.ID); err != nil {
		return err
	}

	if err := z.Host.WriteBinary(w); err != nil {
		return err
	}

	if err := binary.Write(w, binary.LittleEndian, z.Port); err != nil {
		return err
	}

	return nil
}

func (z *MetaPart) ReadBinary(r io.Reader) (err error) {
	defer func() { recover() }()
	if z == nil {
		return fmt.Errorf("ReadBinary: z nil")
	}

	if err := binary.Read(r, binary.LittleEndian, &z.Err); err != nil {
		return err
	}

	if err := binary.Read(r, binary.LittleEndian, &z.ID); err != nil {
		return err
	}

	if err := binary.Read(r, binary.LittleEndian, &z.Leader); err != nil {
		return err
	}

	if err := binary.Read(r, binary.LittleEndian, &z.Replicas); err != nil {
		return err
	}

	if err := binary.Read(r, binary.LittleEndian, &z.ISR); err != nil {
		return err
	}

	return nil
}

func (z *MetaPart) WriteBinary(w io.Writer) (err error) {
	defer func() { recover() }()

	if err := binary.Write(w, binary.LittleEndian, z.Err); err != nil {
		return err
	}

	if err := binary.Write(w, binary.LittleEndian, z.ID); err != nil {
		return err
	}

	if err := binary.Write(w, binary.LittleEndian, z.Leader); err != nil {
		return err
	}

	if err := binary.Write(w, binary.LittleEndian, z.Replicas); err != nil {
		return err
	}

	if err := binary.Write(w, binary.LittleEndian, z.ISR); err != nil {
		return err
	}

	return nil
}

func (z *MetaTopic) ReadBinary(r io.Reader) (err error) {
	defer func() { recover() }()
	if z == nil {
		return fmt.Errorf("ReadBinary: z nil")
	}

	if err := binary.Read(r, binary.LittleEndian, &z.Err); err != nil {
		return err
	}

	if err := z.Topic.ReadBinary(r); err != nil {
		return err
	}

	if err := binary.Read(r, binary.LittleEndian, &z.N); err != nil {
		return err
	}

	z.MetaParts = make([]MetaPart, int(z.N))
	for i := 0; i < int(z.N); i++ {

		if err := z.MetaParts[i].ReadBinary(r); err != nil {
			return err
		}
	}

	return nil
}

func (z *MetaTopic) WriteBinary(w io.Writer) (err error) {
	defer func() { recover() }()

	if err := binary.Write(w, binary.LittleEndian, z.Err); err != nil {
		return err
	}

	if err := z.Topic.WriteBinary(w); err != nil {
		return err
	}

	if err := binary.Write(w, binary.LittleEndian, z.N); err != nil {
		return err
	}

	z.MetaParts = make([]MetaPart, int(z.N))
	for i := 0; i < int(z.N); i++ {
		if err := z.MetaParts[i].WriteBinary(w); err != nil {
			return err
		}
	}

	return nil
}

func (z *MetaTopicTX) ReadBinary(r io.Reader) (err error) {
	defer func() { recover() }()
	if z == nil {
		return fmt.Errorf("ReadBinary: z nil")
	}

	if err := binary.Read(r, binary.LittleEndian, &z.N); err != nil {
		return err
	}

	z.Topics = make([]Str, int(z.N))
	for i := 0; i < int(z.N); i++ {

		if err := z.Topics[i].ReadBinary(r); err != nil {
			return err
		}
	}

	return nil
}

func (z *MetaTopicTX) WriteBinary(w io.Writer) (err error) {
	defer func() { recover() }()

	if err := binary.Write(w, binary.LittleEndian, z.N); err != nil {
		return err
	}

	z.Topics = make([]Str, int(z.N))
	for i := 0; i < int(z.N); i++ {
		if err := z.Topics[i].WriteBinary(w); err != nil {
			return err
		}
	}

	return nil
}

func (z *MetaTopicRX) ReadBinary(r io.Reader) (err error) {
	defer func() { recover() }()
	if z == nil {
		return fmt.Errorf("ReadBinary: z nil")
	}

	if err := binary.Read(r, binary.LittleEndian, &z.N); err != nil {
		return err
	}

	z.Brokers = make([]Broker, int(z.N))
	for i := 0; i < int(z.N); i++ {

		if err := z.Brokers[i].ReadBinary(r); err != nil {
			return err
		}
	}

	if err := binary.Read(r, binary.LittleEndian, &z.M); err != nil {
		return err
	}

	z.Topics = make([]MetaTopic, int(z.M))
	for i := 0; i < int(z.M); i++ {

		if err := z.Topics[i].ReadBinary(r); err != nil {
			return err
		}
	}

	return nil
}

func (z *MetaTopicRX) WriteBinary(w io.Writer) (err error) {
	defer func() { recover() }()

	if err := binary.Write(w, binary.LittleEndian, z.N); err != nil {
		return err
	}

	z.Brokers = make([]Broker, int(z.N))
	for i := 0; i < int(z.N); i++ {
		if err := z.Brokers[i].WriteBinary(w); err != nil {
			return err
		}
	}

	if err := binary.Write(w, binary.LittleEndian, z.M); err != nil {
		return err
	}

	z.Topics = make([]MetaTopic, int(z.M))
	for i := 0; i < int(z.M); i++ {
		if err := z.Topics[i].WriteBinary(w); err != nil {
			return err
		}
	}

	return nil
}

func (z *ProdTXPart) ReadBinary(r io.Reader) (err error) {
	defer func() { recover() }()
	if z == nil {
		return fmt.Errorf("ReadBinary: z nil")
	}

	if err := binary.Read(r, binary.LittleEndian, &z.ID); err != nil {
		return err
	}

	if err := binary.Read(r, binary.LittleEndian, &z.MessageSetSize); err != nil {
		return err
	}

	if err := binary.Read(r, binary.LittleEndian, &z.MessageSet); err != nil {
		return err
	}

	return nil
}

func (z *ProdTXPart) WriteBinary(w io.Writer) (err error) {
	defer func() { recover() }()

	if err := binary.Write(w, binary.LittleEndian, z.ID); err != nil {
		return err
	}

	if err := binary.Write(w, binary.LittleEndian, z.MessageSetSize); err != nil {
		return err
	}

	if err := binary.Write(w, binary.LittleEndian, z.MessageSet); err != nil {
		return err
	}

	return nil
}

func (z *ProdTXTopic) ReadBinary(r io.Reader) (err error) {
	defer func() { recover() }()
	if z == nil {
		return fmt.Errorf("ReadBinary: z nil")
	}

	if err := z.Name.ReadBinary(r); err != nil {
		return err
	}

	if err := binary.Read(r, binary.LittleEndian, &z.N); err != nil {
		return err
	}

	z.Parts = make([]ProdTxPart, int(z.N))
	for i := 0; i < int(z.N); i++ {

		if err := z.Parts[i].ReadBinary(r); err != nil {
			return err
		}
	}

	return nil
}

func (z *ProdTXTopic) WriteBinary(w io.Writer) (err error) {
	defer func() { recover() }()

	if err := z.Name.WriteBinary(w); err != nil {
		return err
	}

	if err := binary.Write(w, binary.LittleEndian, z.N); err != nil {
		return err
	}

	z.Parts = make([]ProdTxPart, int(z.N))
	for i := 0; i < int(z.N); i++ {
		if err := z.Parts[i].WriteBinary(w); err != nil {
			return err
		}
	}

	return nil
}

func (z *ProdTX) ReadBinary(r io.Reader) (err error) {
	defer func() { recover() }()
	if z == nil {
		return fmt.Errorf("ReadBinary: z nil")
	}

	if err := binary.Read(r, binary.LittleEndian, &z.NeedAcks); err != nil {
		return err
	}

	if err := binary.Read(r, binary.LittleEndian, &z.Timeout); err != nil {
		return err
	}

	if err := binary.Read(r, binary.LittleEndian, &z.N); err != nil {
		return err
	}

	z.Topics = make([]ProdTXTopic, int(z.N))
	for i := 0; i < int(z.N); i++ {

		if err := z.Topics[i].ReadBinary(r); err != nil {
			return err
		}
	}

	return nil
}

func (z *ProdTX) WriteBinary(w io.Writer) (err error) {
	defer func() { recover() }()

	if err := binary.Write(w, binary.LittleEndian, z.NeedAcks); err != nil {
		return err
	}

	if err := binary.Write(w, binary.LittleEndian, z.Timeout); err != nil {
		return err
	}

	if err := binary.Write(w, binary.LittleEndian, z.N); err != nil {
		return err
	}

	z.Topics = make([]ProdTXTopic, int(z.N))
	for i := 0; i < int(z.N); i++ {
		if err := z.Topics[i].WriteBinary(w); err != nil {
			return err
		}
	}

	return nil
}

func (z *ProdRXPart) ReadBinary(r io.Reader) (err error) {
	defer func() { recover() }()
	if z == nil {
		return fmt.Errorf("ReadBinary: z nil")
	}

	if err := binary.Read(r, binary.LittleEndian, &z.ID); err != nil {
		return err
	}

	if err := binary.Read(r, binary.LittleEndian, &z.Err); err != nil {
		return err
	}

	if err := binary.Read(r, binary.LittleEndian, &z.Offset); err != nil {
		return err
	}

	if err := binary.Read(r, binary.LittleEndian, &z.Time); err != nil {
		return err
	}

	return nil
}

func (z *ProdRXPart) WriteBinary(w io.Writer) (err error) {
	defer func() { recover() }()

	if err := binary.Write(w, binary.LittleEndian, z.ID); err != nil {
		return err
	}

	if err := binary.Write(w, binary.LittleEndian, z.Err); err != nil {
		return err
	}

	if err := binary.Write(w, binary.LittleEndian, z.Offset); err != nil {
		return err
	}

	if err := binary.Write(w, binary.LittleEndian, z.Time); err != nil {
		return err
	}

	return nil
}

func (z *ProdRXTopic) ReadBinary(r io.Reader) (err error) {
	defer func() { recover() }()
	if z == nil {
		return fmt.Errorf("ReadBinary: z nil")
	}

	if err := z.Name.ReadBinary(r); err != nil {
		return err
	}

	if err := binary.Read(r, binary.LittleEndian, &z.N); err != nil {
		return err
	}

	z.Parts = make([]ProdRXPart, int(z.N))
	for i := 0; i < int(z.N); i++ {

		if err := z.Parts[i].ReadBinary(r); err != nil {
			return err
		}
	}

	return nil
}

func (z *ProdRXTopic) WriteBinary(w io.Writer) (err error) {
	defer func() { recover() }()

	if err := z.Name.WriteBinary(w); err != nil {
		return err
	}

	if err := binary.Write(w, binary.LittleEndian, z.N); err != nil {
		return err
	}

	z.Parts = make([]ProdRXPart, int(z.N))
	for i := 0; i < int(z.N); i++ {
		if err := z.Parts[i].WriteBinary(w); err != nil {
			return err
		}
	}

	return nil
}

func (z *ProdRX) ReadBinary(r io.Reader) (err error) {
	defer func() { recover() }()
	if z == nil {
		return fmt.Errorf("ReadBinary: z nil")
	}

	if err := binary.Read(r, binary.LittleEndian, &z.N); err != nil {
		return err
	}

	z.Topics = make([]ProdRXTopic, int(z.N))
	for i := 0; i < int(z.N); i++ {

		if err := z.Topics[i].ReadBinary(r); err != nil {
			return err
		}
	}

	if err := binary.Read(r, binary.LittleEndian, &z.ThrottleTime); err != nil {
		return err
	}

	return nil
}

func (z *ProdRX) WriteBinary(w io.Writer) (err error) {
	defer func() { recover() }()

	if err := binary.Write(w, binary.LittleEndian, z.N); err != nil {
		return err
	}

	z.Topics = make([]ProdRXTopic, int(z.N))
	for i := 0; i < int(z.N); i++ {
		if err := z.Topics[i].WriteBinary(w); err != nil {
			return err
		}
	}

	if err := binary.Write(w, binary.LittleEndian, z.ThrottleTime); err != nil {
		return err
	}

	return nil
}

func (z *FetchTXPart) ReadBinary(r io.Reader) (err error) {
	defer func() { recover() }()
	if z == nil {
		return fmt.Errorf("ReadBinary: z nil")
	}

	if err := binary.Read(r, binary.LittleEndian, &z.ID); err != nil {
		return err
	}

	if err := binary.Read(r, binary.LittleEndian, &z.Offset); err != nil {
		return err
	}

	if err := binary.Read(r, binary.LittleEndian, &z.MaxBytes); err != nil {
		return err
	}

	return nil
}

func (z *FetchTXPart) WriteBinary(w io.Writer) (err error) {
	defer func() { recover() }()

	if err := binary.Write(w, binary.LittleEndian, z.ID); err != nil {
		return err
	}

	if err := binary.Write(w, binary.LittleEndian, z.Offset); err != nil {
		return err
	}

	if err := binary.Write(w, binary.LittleEndian, z.MaxBytes); err != nil {
		return err
	}

	return nil
}

func (z *FetchTXTopic) ReadBinary(r io.Reader) (err error) {
	defer func() { recover() }()
	if z == nil {
		return fmt.Errorf("ReadBinary: z nil")
	}

	if err := z.Name.ReadBinary(r); err != nil {
		return err
	}

	if err := binary.Read(r, binary.LittleEndian, &z.N); err != nil {
		return err
	}

	z.Parts = make([]FetchTXPart, int(z.N))
	for i := 0; i < int(z.N); i++ {

		if err := z.Parts[i].ReadBinary(r); err != nil {
			return err
		}
	}

	return nil
}

func (z *FetchTXTopic) WriteBinary(w io.Writer) (err error) {
	defer func() { recover() }()

	if err := z.Name.WriteBinary(w); err != nil {
		return err
	}

	if err := binary.Write(w, binary.LittleEndian, z.N); err != nil {
		return err
	}

	z.Parts = make([]FetchTXPart, int(z.N))
	for i := 0; i < int(z.N); i++ {
		if err := z.Parts[i].WriteBinary(w); err != nil {
			return err
		}
	}

	return nil
}

func (z *FetchTX) ReadBinary(r io.Reader) (err error) {
	defer func() { recover() }()
	if z == nil {
		return fmt.Errorf("ReadBinary: z nil")
	}

	if err := binary.Read(r, binary.LittleEndian, &z.ReplicaId); err != nil {
		return err
	}

	if err := binary.Read(r, binary.LittleEndian, &z.MaxWait); err != nil {
		return err
	}

	if err := binary.Read(r, binary.LittleEndian, &z.MinBytes); err != nil {
		return err
	}

	if err := binary.Read(r, binary.LittleEndian, &z.N); err != nil {
		return err
	}

	z.Topic = make([]FetchTXTopic, int(z.N))
	for i := 0; i < int(z.N); i++ {

		if err := z.Topic[i].ReadBinary(r); err != nil {
			return err
		}
	}

	return nil
}

func (z *FetchTX) WriteBinary(w io.Writer) (err error) {
	defer func() { recover() }()

	if err := binary.Write(w, binary.LittleEndian, z.ReplicaId); err != nil {
		return err
	}

	if err := binary.Write(w, binary.LittleEndian, z.MaxWait); err != nil {
		return err
	}

	if err := binary.Write(w, binary.LittleEndian, z.MinBytes); err != nil {
		return err
	}

	if err := binary.Write(w, binary.LittleEndian, z.N); err != nil {
		return err
	}

	z.Topic = make([]FetchTXTopic, int(z.N))
	for i := 0; i < int(z.N); i++ {
		if err := z.Topic[i].WriteBinary(w); err != nil {
			return err
		}
	}

	return nil
}

func (z *FetchRXPart) ReadBinary(r io.Reader) (err error) {
	defer func() { recover() }()
	if z == nil {
		return fmt.Errorf("ReadBinary: z nil")
	}

	if err := binary.Read(r, binary.LittleEndian, &z.ID); err != nil {
		return err
	}

	if err := binary.Read(r, binary.LittleEndian, &z.Err); err != nil {
		return err
	}

	if err := binary.Read(r, binary.LittleEndian, &z.HiWater); err != nil {
		return err
	}

	if err := binary.Read(r, binary.LittleEndian, &z.MessageSetSize); err != nil {
		return err
	}

	if err := binary.Read(r, binary.LittleEndian, &z.MessageSet); err != nil {
		return err
	}

	return nil
}

func (z *FetchRXPart) WriteBinary(w io.Writer) (err error) {
	defer func() { recover() }()

	if err := binary.Write(w, binary.LittleEndian, z.ID); err != nil {
		return err
	}

	if err := binary.Write(w, binary.LittleEndian, z.Err); err != nil {
		return err
	}

	if err := binary.Write(w, binary.LittleEndian, z.HiWater); err != nil {
		return err
	}

	if err := binary.Write(w, binary.LittleEndian, z.MessageSetSize); err != nil {
		return err
	}

	if err := binary.Write(w, binary.LittleEndian, z.MessageSet); err != nil {
		return err
	}

	return nil
}

func (z *FetchRXTopic) ReadBinary(r io.Reader) (err error) {
	defer func() { recover() }()
	if z == nil {
		return fmt.Errorf("ReadBinary: z nil")
	}

	if err := z.Name.ReadBinary(r); err != nil {
		return err
	}

	if err := binary.Read(r, binary.LittleEndian, &z.N); err != nil {
		return err
	}

	z.Parts = make([]FetchRXPart, int(z.N))
	for i := 0; i < int(z.N); i++ {

		if err := z.Parts[i].ReadBinary(r); err != nil {
			return err
		}
	}

	return nil
}

func (z *FetchRXTopic) WriteBinary(w io.Writer) (err error) {
	defer func() { recover() }()

	if err := z.Name.WriteBinary(w); err != nil {
		return err
	}

	if err := binary.Write(w, binary.LittleEndian, z.N); err != nil {
		return err
	}

	z.Parts = make([]FetchRXPart, int(z.N))
	for i := 0; i < int(z.N); i++ {
		if err := z.Parts[i].WriteBinary(w); err != nil {
			return err
		}
	}

	return nil
}

func (z *FetchRX) ReadBinary(r io.Reader) (err error) {
	defer func() { recover() }()
	if z == nil {
		return fmt.Errorf("ReadBinary: z nil")
	}

	if err := binary.Read(r, binary.LittleEndian, &z.ThrottleTime); err != nil {
		return err
	}

	if err := binary.Read(r, binary.LittleEndian, &z.N); err != nil {
		return err
	}

	z.Topics = make([]FetchRXTopic, int(z.N))
	for i := 0; i < int(z.N); i++ {

		if err := z.Topics[i].ReadBinary(r); err != nil {
			return err
		}
	}

	return nil
}

func (z *FetchRX) WriteBinary(w io.Writer) (err error) {
	defer func() { recover() }()

	if err := binary.Write(w, binary.LittleEndian, z.ThrottleTime); err != nil {
		return err
	}

	if err := binary.Write(w, binary.LittleEndian, z.N); err != nil {
		return err
	}

	z.Topics = make([]FetchRXTopic, int(z.N))
	for i := 0; i < int(z.N); i++ {
		if err := z.Topics[i].WriteBinary(w); err != nil {
			return err
		}
	}

	return nil
}

func (z *OffsetTXPart) ReadBinary(r io.Reader) (err error) {
	defer func() { recover() }()
	if z == nil {
		return fmt.Errorf("ReadBinary: z nil")
	}

	if err := binary.Read(r, binary.LittleEndian, &z.ID); err != nil {
		return err
	}

	if err := binary.Read(r, binary.LittleEndian, &z.Time); err != nil {
		return err
	}

	if err := binary.Read(r, binary.LittleEndian, &z.MaxOffsets); err != nil {
		return err
	}

	return nil
}

func (z *OffsetTXPart) WriteBinary(w io.Writer) (err error) {
	defer func() { recover() }()

	if err := binary.Write(w, binary.LittleEndian, z.ID); err != nil {
		return err
	}

	if err := binary.Write(w, binary.LittleEndian, z.Time); err != nil {
		return err
	}

	if err := binary.Write(w, binary.LittleEndian, z.MaxOffsets); err != nil {
		return err
	}

	return nil
}

func (z *OffsetTXTopic) ReadBinary(r io.Reader) (err error) {
	defer func() { recover() }()
	if z == nil {
		return fmt.Errorf("ReadBinary: z nil")
	}

	if err := z.Name.ReadBinary(r); err != nil {
		return err
	}

	if err := binary.Read(r, binary.LittleEndian, &z.N); err != nil {
		return err
	}

	z.Parts = make([]OffsetTXPart, int(z.N))
	for i := 0; i < int(z.N); i++ {

		if err := z.Parts[i].ReadBinary(r); err != nil {
			return err
		}
	}

	return nil
}

func (z *OffsetTXTopic) WriteBinary(w io.Writer) (err error) {
	defer func() { recover() }()

	if err := z.Name.WriteBinary(w); err != nil {
		return err
	}

	if err := binary.Write(w, binary.LittleEndian, z.N); err != nil {
		return err
	}

	z.Parts = make([]OffsetTXPart, int(z.N))
	for i := 0; i < int(z.N); i++ {
		if err := z.Parts[i].WriteBinary(w); err != nil {
			return err
		}
	}

	return nil
}

func (z *OffsetTX) ReadBinary(r io.Reader) (err error) {
	defer func() { recover() }()
	if z == nil {
		return fmt.Errorf("ReadBinary: z nil")
	}

	if err := binary.Read(r, binary.LittleEndian, &z.ReplicaId); err != nil {
		return err
	}

	if err := binary.Read(r, binary.LittleEndian, &z.N); err != nil {
		return err
	}

	z.Topics = make([]OffsetTXTopic, int(z.N))
	for i := 0; i < int(z.N); i++ {

		if err := z.Topics[i].ReadBinary(r); err != nil {
			return err
		}
	}

	return nil
}

func (z *OffsetTX) WriteBinary(w io.Writer) (err error) {
	defer func() { recover() }()

	if err := binary.Write(w, binary.LittleEndian, z.ReplicaId); err != nil {
		return err
	}

	if err := binary.Write(w, binary.LittleEndian, z.N); err != nil {
		return err
	}

	z.Topics = make([]OffsetTXTopic, int(z.N))
	for i := 0; i < int(z.N); i++ {
		if err := z.Topics[i].WriteBinary(w); err != nil {
			return err
		}
	}

	return nil
}

func (z *Offset) ReadBinary(r io.Reader) (err error) {
	defer func() { recover() }()
	if z == nil {
		return fmt.Errorf("ReadBinary: z nil")
	}

	if err := binary.Read(r, binary.LittleEndian, &z.Q0); err != nil {
		return err
	}

	return nil
}

func (z *Offset) WriteBinary(w io.Writer) (err error) {
	defer func() { recover() }()

	if err := binary.Write(w, binary.LittleEndian, z.Q0); err != nil {
		return err
	}

	return nil
}

func (z *OffsetRXPart) ReadBinary(r io.Reader) (err error) {
	defer func() { recover() }()
	if z == nil {
		return fmt.Errorf("ReadBinary: z nil")
	}

	if err := binary.Read(r, binary.LittleEndian, &z.ID); err != nil {
		return err
	}

	if err := binary.Read(r, binary.LittleEndian, &z.Err); err != nil {
		return err
	}

	if err := binary.Read(r, binary.LittleEndian, &z.Time); err != nil {
		return err
	}

	if err := binary.Read(r, binary.LittleEndian, &z.N); err != nil {
		return err
	}

	z.Offsets = make([]Offset, int(z.N))
	for i := 0; i < int(z.N); i++ {

		if err := z.Offsets[i].ReadBinary(r); err != nil {
			return err
		}
	}

	return nil
}

func (z *OffsetRXPart) WriteBinary(w io.Writer) (err error) {
	defer func() { recover() }()

	if err := binary.Write(w, binary.LittleEndian, z.ID); err != nil {
		return err
	}

	if err := binary.Write(w, binary.LittleEndian, z.Err); err != nil {
		return err
	}

	if err := binary.Write(w, binary.LittleEndian, z.Time); err != nil {
		return err
	}

	if err := binary.Write(w, binary.LittleEndian, z.N); err != nil {
		return err
	}

	z.Offsets = make([]Offset, int(z.N))
	for i := 0; i < int(z.N); i++ {
		if err := z.Offsets[i].WriteBinary(w); err != nil {
			return err
		}
	}

	return nil
}

func (z *OffsetRXTopic) ReadBinary(r io.Reader) (err error) {
	defer func() { recover() }()
	if z == nil {
		return fmt.Errorf("ReadBinary: z nil")
	}

	if err := z.Name.ReadBinary(r); err != nil {
		return err
	}

	if err := binary.Read(r, binary.LittleEndian, &z.N); err != nil {
		return err
	}

	z.Parts = make([]OffsetRXPart, int(z.N))
	for i := 0; i < int(z.N); i++ {

		if err := z.Parts[i].ReadBinary(r); err != nil {
			return err
		}
	}

	return nil
}

func (z *OffsetRXTopic) WriteBinary(w io.Writer) (err error) {
	defer func() { recover() }()

	if err := z.Name.WriteBinary(w); err != nil {
		return err
	}

	if err := binary.Write(w, binary.LittleEndian, z.N); err != nil {
		return err
	}

	z.Parts = make([]OffsetRXPart, int(z.N))
	for i := 0; i < int(z.N); i++ {
		if err := z.Parts[i].WriteBinary(w); err != nil {
			return err
		}
	}

	return nil
}

func (z *OffsetRX) ReadBinary(r io.Reader) (err error) {
	defer func() { recover() }()
	if z == nil {
		return fmt.Errorf("ReadBinary: z nil")
	}

	if err := binary.Read(r, binary.LittleEndian, &z.N); err != nil {
		return err
	}

	z.Topics = make([]OffsetRXTopic, int(z.N))
	for i := 0; i < int(z.N); i++ {

		if err := z.Topics[i].ReadBinary(r); err != nil {
			return err
		}
	}

	return nil
}

func (z *OffsetRX) WriteBinary(w io.Writer) (err error) {
	defer func() { recover() }()

	if err := binary.Write(w, binary.LittleEndian, z.N); err != nil {
		return err
	}

	z.Topics = make([]OffsetRXTopic, int(z.N))
	for i := 0; i < int(z.N); i++ {
		if err := z.Topics[i].WriteBinary(w); err != nil {
			return err
		}
	}

	return nil
}

func (z *GroupCoTX) ReadBinary(r io.Reader) (err error) {
	defer func() { recover() }()
	if z == nil {
		return fmt.Errorf("ReadBinary: z nil")
	}

	if err := z.Group.ReadBinary(r); err != nil {
		return err
	}

	return nil
}

func (z *GroupCoTX) WriteBinary(w io.Writer) (err error) {
	defer func() { recover() }()

	if err := z.Group.WriteBinary(w); err != nil {
		return err
	}

	return nil
}

func (z *GroupCoRX) ReadBinary(r io.Reader) (err error) {
	defer func() { recover() }()
	if z == nil {
		return fmt.Errorf("ReadBinary: z nil")
	}

	if err := binary.Read(r, binary.LittleEndian, &z.Err); err != nil {
		return err
	}

	if err := binary.Read(r, binary.LittleEndian, &z.ID); err != nil {
		return err
	}

	if err := z.Host.ReadBinary(r); err != nil {
		return err
	}

	if err := binary.Read(r, binary.LittleEndian, &z.Port); err != nil {
		return err
	}

	return nil
}

func (z *GroupCoRX) WriteBinary(w io.Writer) (err error) {
	defer func() { recover() }()

	if err := binary.Write(w, binary.LittleEndian, z.Err); err != nil {
		return err
	}

	if err := binary.Write(w, binary.LittleEndian, z.ID); err != nil {
		return err
	}

	if err := z.Host.WriteBinary(w); err != nil {
		return err
	}

	if err := binary.Write(w, binary.LittleEndian, z.Port); err != nil {
		return err
	}

	return nil
}

func (z *CommitTXPart) ReadBinary(r io.Reader) (err error) {
	defer func() { recover() }()
	if z == nil {
		return fmt.Errorf("ReadBinary: z nil")
	}

	if err := binary.Read(r, binary.LittleEndian, &z.ID); err != nil {
		return err
	}

	if err := binary.Read(r, binary.LittleEndian, &z.Offset); err != nil {
		return err
	}

	if err := z.MetaData.ReadBinary(r); err != nil {
		return err
	}

	return nil
}

func (z *CommitTXPart) WriteBinary(w io.Writer) (err error) {
	defer func() { recover() }()

	if err := binary.Write(w, binary.LittleEndian, z.ID); err != nil {
		return err
	}

	if err := binary.Write(w, binary.LittleEndian, z.Offset); err != nil {
		return err
	}

	if err := z.MetaData.WriteBinary(w); err != nil {
		return err
	}

	return nil
}

func (z *CommitTXTopic) ReadBinary(r io.Reader) (err error) {
	defer func() { recover() }()
	if z == nil {
		return fmt.Errorf("ReadBinary: z nil")
	}

	if err := z.Name.ReadBinary(r); err != nil {
		return err
	}

	if err := binary.Read(r, binary.LittleEndian, &z.N); err != nil {
		return err
	}

	z.Parts = make([]CommitTXPart, int(z.N))
	for i := 0; i < int(z.N); i++ {

		if err := z.Parts[i].ReadBinary(r); err != nil {
			return err
		}
	}

	return nil
}

func (z *CommitTXTopic) WriteBinary(w io.Writer) (err error) {
	defer func() { recover() }()

	if err := z.Name.WriteBinary(w); err != nil {
		return err
	}

	if err := binary.Write(w, binary.LittleEndian, z.N); err != nil {
		return err
	}

	z.Parts = make([]CommitTXPart, int(z.N))
	for i := 0; i < int(z.N); i++ {
		if err := z.Parts[i].WriteBinary(w); err != nil {
			return err
		}
	}

	return nil
}

func (z *CommitTX) ReadBinary(r io.Reader) (err error) {
	defer func() { recover() }()
	if z == nil {
		return fmt.Errorf("ReadBinary: z nil")
	}

	if err := z.Group.ReadBinary(r); err != nil {
		return err
	}

	if err := binary.Read(r, binary.LittleEndian, &z.Gen); err != nil {
		return err
	}

	if err := z.Cons.ReadBinary(r); err != nil {
		return err
	}

	if err := binary.Read(r, binary.LittleEndian, &z.Retain); err != nil {
		return err
	}

	if err := binary.Read(r, binary.LittleEndian, &z.N); err != nil {
		return err
	}

	z.Topics = make([]CommitTXTopic, int(z.N))
	for i := 0; i < int(z.N); i++ {

		if err := z.Topics[i].ReadBinary(r); err != nil {
			return err
		}
	}

	return nil
}

func (z *CommitTX) WriteBinary(w io.Writer) (err error) {
	defer func() { recover() }()

	if err := z.Group.WriteBinary(w); err != nil {
		return err
	}

	if err := binary.Write(w, binary.LittleEndian, z.Gen); err != nil {
		return err
	}

	if err := z.Cons.WriteBinary(w); err != nil {
		return err
	}

	if err := binary.Write(w, binary.LittleEndian, z.Retain); err != nil {
		return err
	}

	if err := binary.Write(w, binary.LittleEndian, z.N); err != nil {
		return err
	}

	z.Topics = make([]CommitTXTopic, int(z.N))
	for i := 0; i < int(z.N); i++ {
		if err := z.Topics[i].WriteBinary(w); err != nil {
			return err
		}
	}

	return nil
}

func (z *CommitRXPart) ReadBinary(r io.Reader) (err error) {
	defer func() { recover() }()
	if z == nil {
		return fmt.Errorf("ReadBinary: z nil")
	}

	if err := binary.Read(r, binary.LittleEndian, &z.ID); err != nil {
		return err
	}

	if err := binary.Read(r, binary.LittleEndian, &z.Err); err != nil {
		return err
	}

	return nil
}

func (z *CommitRXPart) WriteBinary(w io.Writer) (err error) {
	defer func() { recover() }()

	if err := binary.Write(w, binary.LittleEndian, z.ID); err != nil {
		return err
	}

	if err := binary.Write(w, binary.LittleEndian, z.Err); err != nil {
		return err
	}

	return nil
}

func (z *CommitRXTopic) ReadBinary(r io.Reader) (err error) {
	defer func() { recover() }()
	if z == nil {
		return fmt.Errorf("ReadBinary: z nil")
	}

	if err := z.Name.ReadBinary(r); err != nil {
		return err
	}

	if err := binary.Read(r, binary.LittleEndian, &z.N); err != nil {
		return err
	}

	z.Parts = make([]CommitRXPart, int(z.N))
	for i := 0; i < int(z.N); i++ {

		if err := z.Parts[i].ReadBinary(r); err != nil {
			return err
		}
	}

	return nil
}

func (z *CommitRXTopic) WriteBinary(w io.Writer) (err error) {
	defer func() { recover() }()

	if err := z.Name.WriteBinary(w); err != nil {
		return err
	}

	if err := binary.Write(w, binary.LittleEndian, z.N); err != nil {
		return err
	}

	z.Parts = make([]CommitRXPart, int(z.N))
	for i := 0; i < int(z.N); i++ {
		if err := z.Parts[i].WriteBinary(w); err != nil {
			return err
		}
	}

	return nil
}

func (z *CommitRX) ReadBinary(r io.Reader) (err error) {
	defer func() { recover() }()
	if z == nil {
		return fmt.Errorf("ReadBinary: z nil")
	}

	if err := binary.Read(r, binary.LittleEndian, &z.N); err != nil {
		return err
	}

	if err := z.Topic.ReadBinary(r); err != nil {
		return err
	}

	return nil
}

func (z *CommitRX) WriteBinary(w io.Writer) (err error) {
	defer func() { recover() }()

	if err := binary.Write(w, binary.LittleEndian, z.N); err != nil {
		return err
	}

	if err := z.Topic.WriteBinary(w); err != nil {
		return err
	}

	return nil
}

func (z *FetchTXPart) ReadBinary(r io.Reader) (err error) {
	defer func() { recover() }()
	if z == nil {
		return fmt.Errorf("ReadBinary: z nil")
	}

	if err := binary.Read(r, binary.LittleEndian, &z.ID); err != nil {
		return err
	}

	return nil
}

func (z *FetchTXPart) WriteBinary(w io.Writer) (err error) {
	defer func() { recover() }()

	if err := binary.Write(w, binary.LittleEndian, z.ID); err != nil {
		return err
	}

	return nil
}

func (z *FetchTXTopic) ReadBinary(r io.Reader) (err error) {
	defer func() { recover() }()
	if z == nil {
		return fmt.Errorf("ReadBinary: z nil")
	}

	if err := z.Name.ReadBinary(r); err != nil {
		return err
	}

	if err := binary.Read(r, binary.LittleEndian, &z.N); err != nil {
		return err
	}

	z.Parition = make([]FetchTXPart, int(z.N))
	for i := 0; i < int(z.N); i++ {

		if err := z.Parition[i].ReadBinary(r); err != nil {
			return err
		}
	}

	return nil
}

func (z *FetchTXTopic) WriteBinary(w io.Writer) (err error) {
	defer func() { recover() }()

	if err := z.Name.WriteBinary(w); err != nil {
		return err
	}

	if err := binary.Write(w, binary.LittleEndian, z.N); err != nil {
		return err
	}

	z.Parition = make([]FetchTXPart, int(z.N))
	for i := 0; i < int(z.N); i++ {
		if err := z.Parition[i].WriteBinary(w); err != nil {
			return err
		}
	}

	return nil
}

func (z *FetchTX) ReadBinary(r io.Reader) (err error) {
	defer func() { recover() }()
	if z == nil {
		return fmt.Errorf("ReadBinary: z nil")
	}

	if err := z.Group.ReadBinary(r); err != nil {
		return err
	}

	if err := binary.Read(r, binary.LittleEndian, &z.N); err != nil {
		return err
	}

	z.Topic = make([]FetchTXTopic, int(z.N))
	for i := 0; i < int(z.N); i++ {

		if err := z.Topic[i].ReadBinary(r); err != nil {
			return err
		}
	}

	return nil
}

func (z *FetchTX) WriteBinary(w io.Writer) (err error) {
	defer func() { recover() }()

	if err := z.Group.WriteBinary(w); err != nil {
		return err
	}

	if err := binary.Write(w, binary.LittleEndian, z.N); err != nil {
		return err
	}

	z.Topic = make([]FetchTXTopic, int(z.N))
	for i := 0; i < int(z.N); i++ {
		if err := z.Topic[i].WriteBinary(w); err != nil {
			return err
		}
	}

	return nil
}

func (z *FetchRxPart) ReadBinary(r io.Reader) (err error) {
	defer func() { recover() }()
	if z == nil {
		return fmt.Errorf("ReadBinary: z nil")
	}

	if err := binary.Read(r, binary.LittleEndian, &z.ID); err != nil {
		return err
	}

	if err := binary.Read(r, binary.LittleEndian, &z.Offset); err != nil {
		return err
	}

	if err := z.MetaData.ReadBinary(r); err != nil {
		return err
	}

	if err := binary.Read(r, binary.LittleEndian, &z.Err); err != nil {
		return err
	}

	return nil
}

func (z *FetchRxPart) WriteBinary(w io.Writer) (err error) {
	defer func() { recover() }()

	if err := binary.Write(w, binary.LittleEndian, z.ID); err != nil {
		return err
	}

	if err := binary.Write(w, binary.LittleEndian, z.Offset); err != nil {
		return err
	}

	if err := z.MetaData.WriteBinary(w); err != nil {
		return err
	}

	if err := binary.Write(w, binary.LittleEndian, z.Err); err != nil {
		return err
	}

	return nil
}

func (z *FetchRxTopic) ReadBinary(r io.Reader) (err error) {
	defer func() { recover() }()
	if z == nil {
		return fmt.Errorf("ReadBinary: z nil")
	}

	if err := z.Name.ReadBinary(r); err != nil {
		return err
	}

	if err := binary.Read(r, binary.LittleEndian, &z.N); err != nil {
		return err
	}

	z.Parts = make([]FetchTXPart, int(z.N))
	for i := 0; i < int(z.N); i++ {

		if err := z.Parts[i].ReadBinary(r); err != nil {
			return err
		}
	}

	return nil
}

func (z *FetchRxTopic) WriteBinary(w io.Writer) (err error) {
	defer func() { recover() }()

	if err := z.Name.WriteBinary(w); err != nil {
		return err
	}

	if err := binary.Write(w, binary.LittleEndian, z.N); err != nil {
		return err
	}

	z.Parts = make([]FetchTXPart, int(z.N))
	for i := 0; i < int(z.N); i++ {
		if err := z.Parts[i].WriteBinary(w); err != nil {
			return err
		}
	}

	return nil
}

func (z *FetchRX) ReadBinary(r io.Reader) (err error) {
	defer func() { recover() }()
	if z == nil {
		return fmt.Errorf("ReadBinary: z nil")
	}

	if err := binary.Read(r, binary.LittleEndian, &z.N); err != nil {
		return err
	}

	if err := z.Topic.ReadBinary(r); err != nil {
		return err
	}

	return nil
}

func (z *FetchRX) WriteBinary(w io.Writer) (err error) {
	defer func() { recover() }()

	if err := binary.Write(w, binary.LittleEndian, z.N); err != nil {
		return err
	}

	if err := z.Topic.WriteBinary(w); err != nil {
		return err
	}

	return nil
}

func (z *Proto) ReadBinary(r io.Reader) (err error) {
	defer func() { recover() }()
	if z == nil {
		return fmt.Errorf("ReadBinary: z nil")
	}

	if err := z.Name.ReadBinary(r); err != nil {
		return err
	}

	if err := z.MetaData.ReadBinary(r); err != nil {
		return err
	}

	return nil
}

func (z *Proto) WriteBinary(w io.Writer) (err error) {
	defer func() { recover() }()

	if err := z.Name.WriteBinary(w); err != nil {
		return err
	}

	if err := z.MetaData.WriteBinary(w); err != nil {
		return err
	}

	return nil
}

func (z *DefaultProto) ReadBinary(r io.Reader) (err error) {
	defer func() { recover() }()
	if z == nil {
		return fmt.Errorf("ReadBinary: z nil")
	}

	if err := binary.Read(r, binary.LittleEndian, &z.Ver); err != nil {
		return err
	}

	if err := binary.Read(r, binary.LittleEndian, &z.N); err != nil {
		return err
	}

	z.TopicNames = make([]Str, int(z.N))
	for i := 0; i < int(z.N); i++ {

		if err := z.TopicNames[i].ReadBinary(r); err != nil {
			return err
		}
	}

	return nil
}

func (z *DefaultProto) WriteBinary(w io.Writer) (err error) {
	defer func() { recover() }()

	if err := binary.Write(w, binary.LittleEndian, z.Ver); err != nil {
		return err
	}

	if err := binary.Write(w, binary.LittleEndian, z.N); err != nil {
		return err
	}

	z.TopicNames = make([]Str, int(z.N))
	for i := 0; i < int(z.N); i++ {
		if err := z.TopicNames[i].WriteBinary(w); err != nil {
			return err
		}
	}

	return nil
}

func (z *JoinGroupTX) ReadBinary(r io.Reader) (err error) {
	defer func() { recover() }()
	if z == nil {
		return fmt.Errorf("ReadBinary: z nil")
	}

	if err := z.Group.ReadBinary(r); err != nil {
		return err
	}

	if err := binary.Read(r, binary.LittleEndian, &z.Timeout); err != nil {
		return err
	}

	if err := binary.Read(r, binary.LittleEndian, &z.RebalanceTimeout); err != nil {
		return err
	}

	if err := z.Member.ReadBinary(r); err != nil {
		return err
	}

	if err := z.Prototype.ReadBinary(r); err != nil {
		return err
	}

	if err := binary.Read(r, binary.LittleEndian, &z.N); err != nil {
		return err
	}

	z.Protos = make([]Proto, int(z.N))
	for i := 0; i < int(z.N); i++ {

		if err := z.Protos[i].ReadBinary(r); err != nil {
			return err
		}
	}

	return nil
}

func (z *JoinGroupTX) WriteBinary(w io.Writer) (err error) {
	defer func() { recover() }()

	if err := z.Group.WriteBinary(w); err != nil {
		return err
	}

	if err := binary.Write(w, binary.LittleEndian, z.Timeout); err != nil {
		return err
	}

	if err := binary.Write(w, binary.LittleEndian, z.RebalanceTimeout); err != nil {
		return err
	}

	if err := z.Member.WriteBinary(w); err != nil {
		return err
	}

	if err := z.Prototype.WriteBinary(w); err != nil {
		return err
	}

	if err := binary.Write(w, binary.LittleEndian, z.N); err != nil {
		return err
	}

	z.Protos = make([]Proto, int(z.N))
	for i := 0; i < int(z.N); i++ {
		if err := z.Protos[i].WriteBinary(w); err != nil {
			return err
		}
	}

	return nil
}

func (z *JoinGroupRX) ReadBinary(r io.Reader) (err error) {
	defer func() { recover() }()
	if z == nil {
		return fmt.Errorf("ReadBinary: z nil")
	}

	if err := binary.Read(r, binary.LittleEndian, &z.Err); err != nil {
		return err
	}

	if err := binary.Read(r, binary.LittleEndian, &z.GenID); err != nil {
		return err
	}

	if err := z.Proto.ReadBinary(r); err != nil {
		return err
	}

	if err := z.Leader.ReadBinary(r); err != nil {
		return err
	}

	if err := z.Member.ReadBinary(r); err != nil {
		return err
	}

	if err := binary.Read(r, binary.LittleEndian, &z.N); err != nil {
		return err
	}

	z.Members = make([]Proto, int(z.N))
	for i := 0; i < int(z.N); i++ {

		if err := z.Members[i].ReadBinary(r); err != nil {
			return err
		}
	}

	return nil
}

func (z *JoinGroupRX) WriteBinary(w io.Writer) (err error) {
	defer func() { recover() }()

	if err := binary.Write(w, binary.LittleEndian, z.Err); err != nil {
		return err
	}

	if err := binary.Write(w, binary.LittleEndian, z.GenID); err != nil {
		return err
	}

	if err := z.Proto.WriteBinary(w); err != nil {
		return err
	}

	if err := z.Leader.WriteBinary(w); err != nil {
		return err
	}

	if err := z.Member.WriteBinary(w); err != nil {
		return err
	}

	if err := binary.Write(w, binary.LittleEndian, z.N); err != nil {
		return err
	}

	z.Members = make([]Proto, int(z.N))
	for i := 0; i < int(z.N); i++ {
		if err := z.Members[i].WriteBinary(w); err != nil {
			return err
		}
	}

	return nil
}

func (z *AssignPart) ReadBinary(r io.Reader) (err error) {
	defer func() { recover() }()
	if z == nil {
		return fmt.Errorf("ReadBinary: z nil")
	}

	if err := binary.Read(r, binary.LittleEndian, &z.ID); err != nil {
		return err
	}

	return nil
}

func (z *AssignPart) WriteBinary(w io.Writer) (err error) {
	defer func() { recover() }()

	if err := binary.Write(w, binary.LittleEndian, z.ID); err != nil {
		return err
	}

	return nil
}

func (z *AssignTopic) ReadBinary(r io.Reader) (err error) {
	defer func() { recover() }()
	if z == nil {
		return fmt.Errorf("ReadBinary: z nil")
	}

	if err := binary.Read(r, binary.LittleEndian, &z.N); err != nil {
		return err
	}

	z.Parts = make([]AssignPart, int(z.N))
	for i := 0; i < int(z.N); i++ {

		if err := z.Parts[i].ReadBinary(r); err != nil {
			return err
		}
	}

	return nil
}

func (z *AssignTopic) WriteBinary(w io.Writer) (err error) {
	defer func() { recover() }()

	if err := binary.Write(w, binary.LittleEndian, z.N); err != nil {
		return err
	}

	z.Parts = make([]AssignPart, int(z.N))
	for i := 0; i < int(z.N); i++ {
		if err := z.Parts[i].WriteBinary(w); err != nil {
			return err
		}
	}

	return nil
}

func (z *AssignMember) ReadBinary(r io.Reader) (err error) {
	defer func() { recover() }()
	if z == nil {
		return fmt.Errorf("ReadBinary: z nil")
	}

	if err := binary.Read(r, binary.LittleEndian, &z.Ver); err != nil {
		return err
	}

	if err := binary.Read(r, binary.LittleEndian, &z.N); err != nil {
		return err
	}

	z.Parts = make([]AssignTopic, int(z.N))
	for i := 0; i < int(z.N); i++ {

		if err := z.Parts[i].ReadBinary(r); err != nil {
			return err
		}
	}

	if err := z.UserData.ReadBinary(r); err != nil {
		return err
	}

	return nil
}

func (z *AssignMember) WriteBinary(w io.Writer) (err error) {
	defer func() { recover() }()

	if err := binary.Write(w, binary.LittleEndian, z.Ver); err != nil {
		return err
	}

	if err := binary.Write(w, binary.LittleEndian, z.N); err != nil {
		return err
	}

	z.Parts = make([]AssignTopic, int(z.N))
	for i := 0; i < int(z.N); i++ {
		if err := z.Parts[i].WriteBinary(w); err != nil {
			return err
		}
	}

	if err := z.UserData.WriteBinary(w); err != nil {
		return err
	}

	return nil
}

func (z *GroupAssign) ReadBinary(r io.Reader) (err error) {
	defer func() { recover() }()
	if z == nil {
		return fmt.Errorf("ReadBinary: z nil")
	}

	if err := z.Member.ReadBinary(r); err != nil {
		return err
	}

	if err := binary.Read(r, binary.LittleEndian, &z.N); err != nil {
		return err
	}

	z.Assigns = make([]AssignMember, int(z.N))
	for i := 0; i < int(z.N); i++ {

		if err := z.Assigns[i].ReadBinary(r); err != nil {
			return err
		}
	}

	return nil
}

func (z *GroupAssign) WriteBinary(w io.Writer) (err error) {
	defer func() { recover() }()

	if err := z.Member.WriteBinary(w); err != nil {
		return err
	}

	if err := binary.Write(w, binary.LittleEndian, z.N); err != nil {
		return err
	}

	z.Assigns = make([]AssignMember, int(z.N))
	for i := 0; i < int(z.N); i++ {
		if err := z.Assigns[i].WriteBinary(w); err != nil {
			return err
		}
	}

	return nil
}

func (z *SyncGroupTX) ReadBinary(r io.Reader) (err error) {
	defer func() { recover() }()
	if z == nil {
		return fmt.Errorf("ReadBinary: z nil")
	}

	if err := z.Group.ReadBinary(r); err != nil {
		return err
	}

	if err := binary.Read(r, binary.LittleEndian, &z.Gen); err != nil {
		return err
	}

	if err := z.Member.ReadBinary(r); err != nil {
		return err
	}

	if err := binary.Read(r, binary.LittleEndian, &z.N); err != nil {
		return err
	}

	z.Assigns = make([]GroupAssign, int(z.N))
	for i := 0; i < int(z.N); i++ {

		if err := z.Assigns[i].ReadBinary(r); err != nil {
			return err
		}
	}

	return nil
}

func (z *SyncGroupTX) WriteBinary(w io.Writer) (err error) {
	defer func() { recover() }()

	if err := z.Group.WriteBinary(w); err != nil {
		return err
	}

	if err := binary.Write(w, binary.LittleEndian, z.Gen); err != nil {
		return err
	}

	if err := z.Member.WriteBinary(w); err != nil {
		return err
	}

	if err := binary.Write(w, binary.LittleEndian, z.N); err != nil {
		return err
	}

	z.Assigns = make([]GroupAssign, int(z.N))
	for i := 0; i < int(z.N); i++ {
		if err := z.Assigns[i].WriteBinary(w); err != nil {
			return err
		}
	}

	return nil
}

func (z *SyncGroupRX) ReadBinary(r io.Reader) (err error) {
	defer func() { recover() }()
	if z == nil {
		return fmt.Errorf("ReadBinary: z nil")
	}

	if err := binary.Read(r, binary.LittleEndian, &z.Err); err != nil {
		return err
	}

	if err := binary.Read(r, binary.LittleEndian, &z.N); err != nil {
		return err
	}

	z.Assigns = make([]AssignMember, int(z.N))
	for i := 0; i < int(z.N); i++ {

		if err := z.Assigns[i].ReadBinary(r); err != nil {
			return err
		}
	}

	return nil
}

func (z *SyncGroupRX) WriteBinary(w io.Writer) (err error) {
	defer func() { recover() }()

	if err := binary.Write(w, binary.LittleEndian, z.Err); err != nil {
		return err
	}

	if err := binary.Write(w, binary.LittleEndian, z.N); err != nil {
		return err
	}

	z.Assigns = make([]AssignMember, int(z.N))
	for i := 0; i < int(z.N); i++ {
		if err := z.Assigns[i].WriteBinary(w); err != nil {
			return err
		}
	}

	return nil
}

func (z *LeaveGroupTX) ReadBinary(r io.Reader) (err error) {
	defer func() { recover() }()
	if z == nil {
		return fmt.Errorf("ReadBinary: z nil")
	}

	if err := z.Group.ReadBinary(r); err != nil {
		return err
	}

	if err := z.Member.ReadBinary(r); err != nil {
		return err
	}

	return nil
}

func (z *LeaveGroupTX) WriteBinary(w io.Writer) (err error) {
	defer func() { recover() }()

	if err := z.Group.WriteBinary(w); err != nil {
		return err
	}

	if err := z.Member.WriteBinary(w); err != nil {
		return err
	}

	return nil
}

func (z *LeaveGroupRX) ReadBinary(r io.Reader) (err error) {
	defer func() { recover() }()
	if z == nil {
		return fmt.Errorf("ReadBinary: z nil")
	}

	if err := binary.Read(r, binary.LittleEndian, &z.Err); err != nil {
		return err
	}

	return nil
}

func (z *LeaveGroupRX) WriteBinary(w io.Writer) (err error) {
	defer func() { recover() }()

	if err := binary.Write(w, binary.LittleEndian, z.Err); err != nil {
		return err
	}

	return nil
}

func (z *HeartTX) ReadBinary(r io.Reader) (err error) {
	defer func() { recover() }()
	if z == nil {
		return fmt.Errorf("ReadBinary: z nil")
	}

	if err := z.Group.ReadBinary(r); err != nil {
		return err
	}

	if err := binary.Read(r, binary.LittleEndian, &z.Gen); err != nil {
		return err
	}

	if err := z.Member.ReadBinary(r); err != nil {
		return err
	}

	return nil
}

func (z *HeartTX) WriteBinary(w io.Writer) (err error) {
	defer func() { recover() }()

	if err := z.Group.WriteBinary(w); err != nil {
		return err
	}

	if err := binary.Write(w, binary.LittleEndian, z.Gen); err != nil {
		return err
	}

	if err := z.Member.WriteBinary(w); err != nil {
		return err
	}

	return nil
}

func (z *HeartRX) ReadBinary(r io.Reader) (err error) {
	defer func() { recover() }()
	if z == nil {
		return fmt.Errorf("ReadBinary: z nil")
	}

	if err := binary.Read(r, binary.LittleEndian, &z.Err); err != nil {
		return err
	}

	return nil
}

func (z *HeartRX) WriteBinary(w io.Writer) (err error) {
	defer func() { recover() }()

	if err := binary.Write(w, binary.LittleEndian, z.Err); err != nil {
		return err
	}

	return nil
}

func (z *GroupList) ReadBinary(r io.Reader) (err error) {
	defer func() { recover() }()
	if z == nil {
		return fmt.Errorf("ReadBinary: z nil")
	}

	if err := z.Group.ReadBinary(r); err != nil {
		return err
	}

	if err := z.Prototype.ReadBinary(r); err != nil {
		return err
	}

	return nil
}

func (z *GroupList) WriteBinary(w io.Writer) (err error) {
	defer func() { recover() }()

	if err := z.Group.WriteBinary(w); err != nil {
		return err
	}

	if err := z.Prototype.WriteBinary(w); err != nil {
		return err
	}

	return nil
}

func (z *ListGroupsTX) ReadBinary(r io.Reader) (err error) {
	defer func() { recover() }()
	if z == nil {
		return fmt.Errorf("ReadBinary: z nil")
	}

	if err := binary.Read(r, binary.LittleEndian, &z.Zero); err != nil {
		return err
	}

	return nil
}

func (z *ListGroupsTX) WriteBinary(w io.Writer) (err error) {
	defer func() { recover() }()

	if err := binary.Write(w, binary.LittleEndian, z.Zero); err != nil {
		return err
	}

	return nil
}

func (z *ListGroupsRX) ReadBinary(r io.Reader) (err error) {
	defer func() { recover() }()
	if z == nil {
		return fmt.Errorf("ReadBinary: z nil")
	}

	if err := binary.Read(r, binary.LittleEndian, &z.Err); err != nil {
		return err
	}

	if err := binary.Read(r, binary.LittleEndian, &z.N); err != nil {
		return err
	}

	z.Groups = make([]GroupList, int(z.N))
	for i := 0; i < int(z.N); i++ {

		if err := z.Groups[i].ReadBinary(r); err != nil {
			return err
		}
	}

	return nil
}

func (z *ListGroupsRX) WriteBinary(w io.Writer) (err error) {
	defer func() { recover() }()

	if err := binary.Write(w, binary.LittleEndian, z.Err); err != nil {
		return err
	}

	if err := binary.Write(w, binary.LittleEndian, z.N); err != nil {
		return err
	}

	z.Groups = make([]GroupList, int(z.N))
	for i := 0; i < int(z.N); i++ {
		if err := z.Groups[i].WriteBinary(w); err != nil {
			return err
		}
	}

	return nil
}

func (z *DescGroupsTX) ReadBinary(r io.Reader) (err error) {
	defer func() { recover() }()
	if z == nil {
		return fmt.Errorf("ReadBinary: z nil")
	}

	if err := binary.Read(r, binary.LittleEndian, &z.N); err != nil {
		return err
	}

	z.Groups = make([]Str, int(z.N))
	for i := 0; i < int(z.N); i++ {

		if err := z.Groups[i].ReadBinary(r); err != nil {
			return err
		}
	}

	return nil
}

func (z *DescGroupsTX) WriteBinary(w io.Writer) (err error) {
	defer func() { recover() }()

	if err := binary.Write(w, binary.LittleEndian, z.N); err != nil {
		return err
	}

	z.Groups = make([]Str, int(z.N))
	for i := 0; i < int(z.N); i++ {
		if err := z.Groups[i].WriteBinary(w); err != nil {
			return err
		}
	}

	return nil
}

func (z *DescGroupMember) ReadBinary(r io.Reader) (err error) {
	defer func() { recover() }()
	if z == nil {
		return fmt.Errorf("ReadBinary: z nil")
	}

	if err := z.Name.ReadBinary(r); err != nil {
		return err
	}

	if err := z.Client.ReadBinary(r); err != nil {
		return err
	}

	if err := z.Host.ReadBinary(r); err != nil {
		return err
	}

	if err := z.MetaData.ReadBinary(r); err != nil {
		return err
	}

	if err := binary.Read(r, binary.LittleEndian, &z.N); err != nil {
		return err
	}

	z.Assigns = make([]GroupAssign, int(z.N))
	for i := 0; i < int(z.N); i++ {

		if err := z.Assigns[i].ReadBinary(r); err != nil {
			return err
		}
	}

	return nil
}

func (z *DescGroupMember) WriteBinary(w io.Writer) (err error) {
	defer func() { recover() }()

	if err := z.Name.WriteBinary(w); err != nil {
		return err
	}

	if err := z.Client.WriteBinary(w); err != nil {
		return err
	}

	if err := z.Host.WriteBinary(w); err != nil {
		return err
	}

	if err := z.MetaData.WriteBinary(w); err != nil {
		return err
	}

	if err := binary.Write(w, binary.LittleEndian, z.N); err != nil {
		return err
	}

	z.Assigns = make([]GroupAssign, int(z.N))
	for i := 0; i < int(z.N); i++ {
		if err := z.Assigns[i].WriteBinary(w); err != nil {
			return err
		}
	}

	return nil
}

func (z *DescGroup) ReadBinary(r io.Reader) (err error) {
	defer func() { recover() }()
	if z == nil {
		return fmt.Errorf("ReadBinary: z nil")
	}

	if err := binary.Read(r, binary.LittleEndian, &z.Err); err != nil {
		return err
	}

	if err := z.Group.ReadBinary(r); err != nil {
		return err
	}

	if err := z.State.ReadBinary(r); err != nil {
		return err
	}

	if err := z.Prototype.ReadBinary(r); err != nil {
		return err
	}

	if err := z.Proto.ReadBinary(r); err != nil {
		return err
	}

	if err := binary.Read(r, binary.LittleEndian, &z.N); err != nil {
		return err
	}

	z.Members = make([]DescGroupMember, int(z.N))
	for i := 0; i < int(z.N); i++ {

		if err := z.Members[i].ReadBinary(r); err != nil {
			return err
		}
	}

	return nil
}

func (z *DescGroup) WriteBinary(w io.Writer) (err error) {
	defer func() { recover() }()

	if err := binary.Write(w, binary.LittleEndian, z.Err); err != nil {
		return err
	}

	if err := z.Group.WriteBinary(w); err != nil {
		return err
	}

	if err := z.State.WriteBinary(w); err != nil {
		return err
	}

	if err := z.Prototype.WriteBinary(w); err != nil {
		return err
	}

	if err := z.Proto.WriteBinary(w); err != nil {
		return err
	}

	if err := binary.Write(w, binary.LittleEndian, z.N); err != nil {
		return err
	}

	z.Members = make([]DescGroupMember, int(z.N))
	for i := 0; i < int(z.N); i++ {
		if err := z.Members[i].WriteBinary(w); err != nil {
			return err
		}
	}

	return nil
}

func (z *DescGroupsRX) ReadBinary(r io.Reader) (err error) {
	defer func() { recover() }()
	if z == nil {
		return fmt.Errorf("ReadBinary: z nil")
	}

	if err := binary.Read(r, binary.LittleEndian, &z.Err); err != nil {
		return err
	}

	if err := z.Group.ReadBinary(r); err != nil {
		return err
	}

	return nil
}

func (z *DescGroupsRX) WriteBinary(w io.Writer) (err error) {
	defer func() { recover() }()

	if err := binary.Write(w, binary.LittleEndian, z.Err); err != nil {
		return err
	}

	if err := z.Group.WriteBinary(w); err != nil {
		return err
	}

	return nil
}
